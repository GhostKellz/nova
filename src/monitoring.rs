use crate::{log_debug, log_error, log_info, log_warn, NovaError, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::process::{Command, Stdio};
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use tokio::time::sleep;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkStats {
    pub interface: String,
    pub timestamp: u64,
    pub rx_bytes: u64,
    pub tx_bytes: u64,
    pub rx_packets: u64,
    pub tx_packets: u64,
    pub rx_errors: u64,
    pub tx_errors: u64,
    pub rx_drops: u64,
    pub tx_drops: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BandwidthUsage {
    pub interface: String,
    pub timestamp: u64,
    pub rx_bps: f64, // bytes per second
    pub tx_bps: f64,
    pub rx_pps: f64, // packets per second
    pub tx_pps: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionInfo {
    pub local_addr: String,
    pub remote_addr: String,
    pub state: String,
    pub protocol: String,
    pub process: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PacketCaptureConfig {
    pub interface: String,
    pub filter: Option<String>, // BPF filter
    pub duration: Option<u64>,  // seconds
    pub packet_count: Option<u64>,
    pub output_file: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTopology {
    pub bridges: Vec<TopologyBridge>,
    pub connections: Vec<TopologyConnection>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopologyBridge {
    pub name: String,
    pub bridge_type: String, // "linux", "ovs"
    pub interfaces: Vec<String>,
    pub ip_address: Option<String>,
    pub status: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopologyConnection {
    pub from: String,
    pub to: String,
    pub connection_type: String, // "bridge", "veth", "tap"
    pub bandwidth: Option<f64>,
}

pub struct NetworkMonitor {
    stats_history: HashMap<String, Vec<NetworkStats>>,
    bandwidth_history: HashMap<String, Vec<BandwidthUsage>>,
    monitoring_active: bool,
}

impl NetworkMonitor {
    pub fn new() -> Self {
        Self {
            stats_history: HashMap::new(),
            bandwidth_history: HashMap::new(),
            monitoring_active: false,
        }
    }

    // Start continuous monitoring
    pub async fn start_monitoring(&mut self, interfaces: Vec<String>, interval_seconds: u64) -> Result<()> {\n        log_info!(\"Starting network monitoring for {} interfaces\", interfaces.len());\n\n        self.monitoring_active = true;\n        let monitor_interfaces = interfaces.clone();\n\n        tokio::spawn(async move {\n            let mut previous_stats: HashMap<String, NetworkStats> = HashMap::new();\n\n            while self.monitoring_active {\n                for interface in &monitor_interfaces {\n                    if let Ok(current_stats) = self.get_interface_stats(interface).await {\n                        // Store current stats\n                        self.stats_history\n                            .entry(interface.clone())\n                            .or_insert_with(Vec::new)\n                            .push(current_stats.clone());\n\n                        // Calculate bandwidth if we have previous data\n                        if let Some(prev_stats) = previous_stats.get(interface) {\n                            if let Ok(bandwidth) = self.calculate_bandwidth(&current_stats, prev_stats) {\n                                self.bandwidth_history\n                                    .entry(interface.clone())\n                                    .or_insert_with(Vec::new)\n                                    .push(bandwidth);\n                            }\n                        }\n\n                        previous_stats.insert(interface.clone(), current_stats);\n                    }\n                }\n\n                // Keep only last 1000 entries per interface to prevent memory growth\n                for history in self.stats_history.values_mut() {\n                    if history.len() > 1000 {\n                        history.drain(0..history.len() - 1000);\n                    }\n                }\n                for history in self.bandwidth_history.values_mut() {\n                    if history.len() > 1000 {\n                        history.drain(0..history.len() - 1000);\n                    }\n                }\n\n                sleep(Duration::from_secs(interval_seconds)).await;\n            }\n        });\n\n        Ok(())\n    }\n\n    pub fn stop_monitoring(&mut self) {\n        log_info!(\"Stopping network monitoring\");\n        self.monitoring_active = false;\n    }\n\n    // Get current network statistics for an interface\n    pub async fn get_interface_stats(&self, interface: &str) -> Result<NetworkStats> {\n        let proc_net_dev = std::fs::read_to_string(\"/proc/net/dev\")\n            .map_err(|_| NovaError::SystemCommandFailed)?;\n\n        for line in proc_net_dev.lines() {\n            if line.contains(interface) && line.contains(\":\") {\n                let parts: Vec<&str> = line.split_whitespace().collect();\n                if parts.len() >= 17 {\n                    let timestamp = SystemTime::now()\n                        .duration_since(UNIX_EPOCH)\n                        .unwrap()\n                        .as_secs();\n\n                    return Ok(NetworkStats {\n                        interface: interface.to_string(),\n                        timestamp,\n                        rx_bytes: parts[1].parse().unwrap_or(0),\n                        rx_packets: parts[2].parse().unwrap_or(0),\n                        rx_errors: parts[3].parse().unwrap_or(0),\n                        rx_drops: parts[4].parse().unwrap_or(0),\n                        tx_bytes: parts[9].parse().unwrap_or(0),\n                        tx_packets: parts[10].parse().unwrap_or(0),\n                        tx_errors: parts[11].parse().unwrap_or(0),\n                        tx_drops: parts[12].parse().unwrap_or(0),\n                    });\n                }\n            }\n        }\n\n        Err(NovaError::NetworkNotFound(interface.to_string()))\n    }\n\n    // Calculate bandwidth between two stat samples\n    fn calculate_bandwidth(&self, current: &NetworkStats, previous: &NetworkStats) -> Result<BandwidthUsage> {\n        let time_diff = current.timestamp.saturating_sub(previous.timestamp) as f64;\n        if time_diff == 0.0 {\n            return Err(NovaError::InvalidConfig);\n        }\n\n        let rx_bytes_diff = current.rx_bytes.saturating_sub(previous.rx_bytes) as f64;\n        let tx_bytes_diff = current.tx_bytes.saturating_sub(previous.tx_bytes) as f64;\n        let rx_packets_diff = current.rx_packets.saturating_sub(previous.rx_packets) as f64;\n        let tx_packets_diff = current.tx_packets.saturating_sub(previous.tx_packets) as f64;\n\n        Ok(BandwidthUsage {\n            interface: current.interface.clone(),\n            timestamp: current.timestamp,\n            rx_bps: rx_bytes_diff / time_diff,\n            tx_bps: tx_bytes_diff / time_diff,\n            rx_pps: rx_packets_diff / time_diff,\n            tx_pps: tx_packets_diff / time_diff,\n        })\n    }\n\n    // Get current bandwidth usage\n    pub fn get_current_bandwidth(&self, interface: &str) -> Option<&BandwidthUsage> {\n        self.bandwidth_history.get(interface)?.last()\n    }\n\n    // Get bandwidth history for an interface\n    pub fn get_bandwidth_history(&self, interface: &str, limit: Option<usize>) -> Vec<&BandwidthUsage> {\n        if let Some(history) = self.bandwidth_history.get(interface) {\n            if let Some(limit) = limit {\n                history.iter().rev().take(limit).collect()\n            } else {\n                history.iter().collect()\n            }\n        } else {\n            Vec::new()\n        }\n    }\n\n    // Packet Capture Integration\n    pub async fn start_packet_capture(&self, config: &PacketCaptureConfig) -> Result<String> {\n        log_info!(\"Starting packet capture on interface: {}\", config.interface);\n\n        let mut cmd = Command::new(\"tcpdump\");\n        cmd.args(&[\"-i\", &config.interface]);\n        cmd.args(&[\"-w\", &config.output_file]);\n\n        // Add filter if specified\n        if let Some(filter) = &config.filter {\n            cmd.arg(filter);\n        }\n\n        // Add packet count limit if specified\n        if let Some(count) = config.packet_count {\n            cmd.args(&[\"-c\", &count.to_string()]);\n        }\n\n        // Set capture duration if specified\n        if let Some(duration) = config.duration {\n            cmd.args(&[\"-G\", &duration.to_string()]);\n            cmd.args(&[\"-W\", \"1\"]); // Only one file\n        }\n\n        // Run in background\n        let child = cmd\n            .stdin(Stdio::null())\n            .stdout(Stdio::null())\n            .stderr(Stdio::piped())\n            .spawn()\n            .map_err(|e| {\n                log_error!(\"Failed to start tcpdump: {}\", e);\n                NovaError::SystemCommandFailed\n            })?;\n\n        let pid = child.id();\n        log_info!(\"Packet capture started with PID: {}\", pid);\n\n        Ok(format!(\"nova-capture-{}\", pid))\n    }\n\n    pub async fn stop_packet_capture(&self, capture_id: &str) -> Result<()> {\n        log_info!(\"Stopping packet capture: {}\", capture_id);\n\n        // Extract PID from capture_id\n        if let Some(pid_str) = capture_id.strip_prefix(\"nova-capture-\") {\n            if let Ok(pid) = pid_str.parse::<u32>() {\n                let output = Command::new(\"kill\")\n                    .args(&[\"-TERM\", &pid.to_string()])\n                    .output()\n                    .map_err(|_| NovaError::SystemCommandFailed)?;\n\n                if output.status.success() {\n                    log_info!(\"Packet capture {} stopped\", capture_id);\n                } else {\n                    log_warn!(\"Failed to stop packet capture {}\", capture_id);\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    // Launch Wireshark for analysis\n    pub async fn launch_wireshark(&self, pcap_file: &str) -> Result<()> {\n        log_info!(\"Launching Wireshark for file: {}\", pcap_file);\n\n        let output = Command::new(\"wireshark\")\n            .arg(pcap_file)\n            .spawn()\n            .map_err(|e| {\n                log_error!(\"Failed to launch Wireshark: {}\", e);\n                NovaError::SystemCommandFailed\n            })?;\n\n        log_info!(\"Wireshark launched for packet analysis\");\n        Ok(())\n    }\n\n    // Network Topology Discovery\n    pub async fn discover_topology(&self) -> Result<NetworkTopology> {\n        log_info!(\"Discovering network topology\");\n\n        let mut topology = NetworkTopology {\n            bridges: Vec::new(),\n            connections: Vec::new(),\n        };\n\n        // Discover Linux bridges\n        self.discover_linux_bridges(&mut topology).await?;\n\n        // Discover OVS bridges if available\n        if self.check_ovs_available() {\n            self.discover_ovs_bridges(&mut topology).await?;\n        }\n\n        // Discover connections between bridges and interfaces\n        self.discover_connections(&mut topology).await?;\n\n        log_info!(\"Discovered {} bridges and {} connections\",\n                 topology.bridges.len(), topology.connections.len());\n\n        Ok(topology)\n    }\n\n    async fn discover_linux_bridges(&self, topology: &mut NetworkTopology) -> Result<()> {\n        // Get list of bridges from /sys/class/net\n        let sys_net = std::fs::read_dir(\"/sys/class/net\")\n            .map_err(|_| NovaError::SystemCommandFailed)?;\n\n        for entry in sys_net {\n            if let Ok(entry) = entry {\n                let bridge_path = entry.path().join(\"bridge\");\n                if bridge_path.exists() {\n                    let bridge_name = entry.file_name().to_string_lossy().to_string();\n                    \n                    // Get bridge interfaces\n                    let mut interfaces = Vec::new();\n                    if let Ok(brif_dir) = std::fs::read_dir(bridge_path.join(\"brif\")) {\n                        for iface_entry in brif_dir {\n                            if let Ok(iface_entry) = iface_entry {\n                                interfaces.push(iface_entry.file_name().to_string_lossy().to_string());\n                            }\n                        }\n                    }\n\n                    // Get bridge IP address\n                    let ip_address = self.get_interface_ip(&bridge_name).await.ok();\n\n                    topology.bridges.push(TopologyBridge {\n                        name: bridge_name,\n                        bridge_type: \"linux\".to_string(),\n                        interfaces,\n                        ip_address,\n                        status: \"active\".to_string(),\n                    });\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn discover_ovs_bridges(&self, topology: &mut NetworkTopology) -> Result<()> {\n        let output = Command::new(\"ovs-vsctl\")\n            .arg(\"list-br\")\n            .output()\n            .map_err(|_| NovaError::SystemCommandFailed)?;\n\n        if !output.status.success() {\n            return Ok(());\n        }\n\n        let bridges = String::from_utf8_lossy(&output.stdout);\n        for bridge_name in bridges.lines() {\n            let bridge_name = bridge_name.trim();\n            if !bridge_name.is_empty() {\n                // Get bridge ports\n                let port_output = Command::new(\"ovs-vsctl\")\n                    .args(&[\"list-ports\", bridge_name])\n                    .output()\n                    .unwrap_or_else(|_| std::process::Output {\n                        status: std::process::ExitStatus::from_raw(1),\n                        stdout: Vec::new(),\n                        stderr: Vec::new(),\n                    });\n\n                let mut interfaces = Vec::new();\n                if port_output.status.success() {\n                    let ports = String::from_utf8_lossy(&port_output.stdout);\n                    for port in ports.lines() {\n                        let port = port.trim();\n                        if !port.is_empty() {\n                            interfaces.push(port.to_string());\n                        }\n                    }\n                }\n\n                let ip_address = self.get_interface_ip(bridge_name).await.ok();\n\n                topology.bridges.push(TopologyBridge {\n                    name: bridge_name.to_string(),\n                    bridge_type: \"ovs\".to_string(),\n                    interfaces,\n                    ip_address,\n                    status: \"active\".to_string(),\n                });\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn discover_connections(&self, topology: &mut NetworkTopology) -> Result<()> {\n        // Discover connections between bridges and their interfaces\n        for bridge in &topology.bridges {\n            for interface in &bridge.interfaces {\n                topology.connections.push(TopologyConnection {\n                    from: bridge.name.clone(),\n                    to: interface.clone(),\n                    connection_type: \"bridge\".to_string(),\n                    bandwidth: None, // Could be populated from monitoring data\n                });\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn get_interface_ip(&self, interface: &str) -> Result<String> {\n        let output = Command::new(\"ip\")\n            .args(&[\"-4\", \"addr\", \"show\", interface])\n            .output()\n            .map_err(|_| NovaError::SystemCommandFailed)?;\n\n        if !output.status.success() {\n            return Err(NovaError::NetworkNotFound(interface.to_string()));\n        }\n\n        let output_str = String::from_utf8_lossy(&output.stdout);\n        for line in output_str.lines() {\n            if line.contains(\"inet \") && !line.contains(\"127.0.0.1\") {\n                if let Some(start) = line.find(\"inet \") {\n                    let ip_part = &line[start + 5..];\n                    if let Some(end) = ip_part.find(' ') {\n                        return Ok(ip_part[..end].to_string());\n                    }\n                }\n            }\n        }\n\n        Err(NovaError::NetworkNotFound(interface.to_string()))\n    }\n\n    // Connection tracking\n    pub async fn get_active_connections(&self) -> Result<Vec<ConnectionInfo>> {\n        log_debug!(\"Getting active network connections\");\n\n        let output = Command::new(\"netstat\")\n            .args(&[\"-tuln\"])\n            .output()\n            .map_err(|_| NovaError::SystemCommandFailed)?;\n\n        if !output.status.success() {\n            return Err(NovaError::SystemCommandFailed);\n        }\n\n        let mut connections = Vec::new();\n        let output_str = String::from_utf8_lossy(&output.stdout);\n\n        for line in output_str.lines() {\n            if line.starts_with(\"tcp\") || line.starts_with(\"udp\") {\n                let parts: Vec<&str> = line.split_whitespace().collect();\n                if parts.len() >= 4 {\n                    connections.push(ConnectionInfo {\n                        protocol: parts[0].to_string(),\n                        local_addr: parts[3].to_string(),\n                        remote_addr: if parts.len() > 4 { parts[4].to_string() } else { \"*\".to_string() },\n                        state: if parts.len() > 5 { parts[5].to_string() } else { \"UNKNOWN\".to_string() },\n                        process: None, // Would need additional parsing with -p flag\n                    });\n                }\n            }\n        }\n\n        Ok(connections)\n    }\n\n    // Utility functions\n    fn check_ovs_available(&self) -> bool {\n        Command::new(\"ovs-vsctl\")\n            .arg(\"--version\")\n            .output()\n            .map(|output| output.status.success())\n            .unwrap_or(false)\n    }\n\n    pub fn check_tcpdump_available(&self) -> bool {\n        Command::new(\"tcpdump\")\n            .arg(\"--version\")\n            .output()\n            .map(|output| output.status.success())\n            .unwrap_or(false)\n    }\n\n    pub fn check_wireshark_available(&self) -> bool {\n        Command::new(\"wireshark\")\n            .arg(\"--version\")\n            .output()\n            .map(|output| output.status.success())\n            .unwrap_or(false)\n    }\n}\n\nimpl Default for NetworkMonitor {\n    fn default() -> Self {\n        Self::new()\n    }\n}"