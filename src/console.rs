use crate::{log_debug, log_error, log_info, log_warn, NovaError, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::process::{Child, Command, Stdio};
use std::sync::{Arc, Mutex};
use tokio::net::{TcpListener, TcpStream};
use tokio::time::{sleep, Duration};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsoleSession {
    pub vm_name: String,
    pub session_id: String,
    pub console_type: ConsoleType,
    pub connection_info: ConnectionInfo,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub last_accessed: chrono::DateTime<chrono::Utc>,
    pub active: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConsoleType {
    VNC,
    SPICE,
    RDP,
    SerialConsole,
    WebConsole,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionInfo {
    pub host: String,
    pub port: u16,
    pub protocol: String,
    pub auth_required: bool,
    pub password: Option<String>,
    pub certificate_path: Option<String>,
    pub websocket_url: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsoleConfig {
    pub vnc_enabled: bool,
    pub vnc_port_range: (u16, u16),
    pub spice_enabled: bool,
    pub spice_port_range: (u16, u16),
    pub rdp_enabled: bool,
    pub rdp_port_range: (u16, u16),
    pub web_console_enabled: bool,
    pub web_console_port: u16,
    pub auth_required: bool,
    pub ssl_enabled: bool,
    pub certificate_path: Option<String>,
    pub key_path: Option<String>,
}

pub struct ConsoleManager {
    sessions: Arc<Mutex<HashMap<String, ConsoleSession>>>,
    config: ConsoleConfig,
    vnc_processes: Arc<Mutex<HashMap<String, Child>>>,
    spice_processes: Arc<Mutex<HashMap<String, Child>>>,
    port_allocator: Arc<Mutex<PortAllocator>>,
}

struct PortAllocator {
    vnc_ports: std::collections::VecDeque<u16>,
    spice_ports: std::collections::VecDeque<u16>,
    rdp_ports: std::collections::VecDeque<u16>,
    allocated_ports: std::collections::HashSet<u16>,
}

impl ConsoleManager {
    pub fn new(config: ConsoleConfig) -> Self {
        let mut vnc_ports = std::collections::VecDeque::new();
        let mut spice_ports = std::collections::VecDeque::new();
        let mut rdp_ports = std::collections::VecDeque::new();

        // Initialize port ranges
        for port in config.vnc_port_range.0..=config.vnc_port_range.1 {
            vnc_ports.push_back(port);
        }
        for port in config.spice_port_range.0..=config.spice_port_range.1 {
            spice_ports.push_back(port);
        }
        for port in config.rdp_port_range.0..=config.rdp_port_range.1 {
            rdp_ports.push_back(port);
        }

        let port_allocator = PortAllocator {
            vnc_ports,
            spice_ports,
            rdp_ports,
            allocated_ports: std::collections::HashSet::new(),
        };

        Self {
            sessions: Arc::new(Mutex::new(HashMap::new())),
            config,
            vnc_processes: Arc::new(Mutex::new(HashMap::new())),
            spice_processes: Arc::new(Mutex::new(HashMap::new())),
            port_allocator: Arc::new(Mutex::new(port_allocator)),
        }
    }

    // Enhanced VNC Console
    pub async fn create_vnc_console(&mut self, vm_name: &str, enhanced: bool) -> Result<ConsoleSession> {
        log_info!(\"Creating {} VNC console for VM: {}\", if enhanced { \"enhanced\" } else { \"standard\" }, vm_name);

        let port = self.allocate_port(ConsoleType::VNC)?;
        let session_id = format!(\"vnc-{}-{}\", vm_name, port);

        // Create VNC server with enhanced features
        let mut vnc_cmd = if enhanced {
            // Use x11vnc with better performance and features
            let mut cmd = Command::new(\"x11vnc\");
            cmd.args(&[\"-create\", \"-shared\", \"-forever\"]);\n            cmd.args(&[\"-rfbport\", &port.to_string()]);\n            \n            if self.config.auth_required {\n                // Generate random password\n                let password = self.generate_password();\n                cmd.args(&[\"-passwd\", &password]);\n            }\n            \n            if self.config.ssl_enabled {\n                if let Some(cert_path) = &self.config.certificate_path {\n                    cmd.args(&[\"-ssl\", cert_path]);\n                }\n            }\n            \n            // Performance optimizations\n            cmd.args(&[\"-noxdamage\", \"-noxfixes\", \"-noxrandr\"]);\n            cmd.args(&[\"-wireframe\", \"-scrollcopyrect\"]);\n            cmd.args(&[\"-ncache\", \"10\"]);\n            \n            cmd\n        } else {\n            // Standard QEMU VNC\n            Command::new(\"qemu-system-x86_64\")\n        };\n\n        let vnc_process = vnc_cmd\n            .stdin(Stdio::null())\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped())\n            .spawn()\n            .map_err(|e| {\n                log_error!(\"Failed to start VNC server: {}\", e);\n                NovaError::SystemCommandFailed\n            })?;\n\n        let connection_info = ConnectionInfo {\n            host: \"localhost\".to_string(),\n            port,\n            protocol: \"vnc\".to_string(),\n            auth_required: self.config.auth_required,\n            password: if self.config.auth_required { Some(self.generate_password()) } else { None },\n            certificate_path: self.config.certificate_path.clone(),\n            websocket_url: if self.config.web_console_enabled {\n                Some(format!(\"ws://localhost:{}/vnc/{}\", self.config.web_console_port, session_id))\n            } else {\n                None\n            },\n        };\n\n        let session = ConsoleSession {\n            vm_name: vm_name.to_string(),\n            session_id: session_id.clone(),\n            console_type: ConsoleType::VNC,\n            connection_info,\n            created_at: chrono::Utc::now(),\n            last_accessed: chrono::Utc::now(),\n            active: true,\n        };\n\n        // Store the process\n        {\n            let mut processes = self.vnc_processes.lock().unwrap();\n            processes.insert(session_id.clone(), vnc_process);\n        }\n\n        // Store the session\n        {\n            let mut sessions = self.sessions.lock().unwrap();\n            sessions.insert(session_id.clone(), session.clone());\n        }\n\n        log_info!(\"VNC console created successfully: {}:{}\", \"localhost\", port);\n        Ok(session)\n    }\n\n    // SPICE Console (Superior performance vs VNC)\n    pub async fn create_spice_console(&mut self, vm_name: &str) -> Result<ConsoleSession> {\n        log_info!(\"Creating SPICE console for VM: {}\", vm_name);\n\n        if !self.check_spice_available() {\n            log_warn!(\"SPICE not available, falling back to VNC\");\n            return self.create_vnc_console(vm_name, true).await;\n        }\n\n        let port = self.allocate_port(ConsoleType::SPICE)?;\n        let session_id = format!(\"spice-{}-{}\", vm_name, port);\n\n        // SPICE provides better performance than VNC:\n        // - Audio/Video redirection\n        // - USB redirection \n        // - Multi-monitor support\n        // - Better compression\n        let connection_info = ConnectionInfo {\n            host: \"localhost\".to_string(),\n            port,\n            protocol: \"spice\".to_string(),\n            auth_required: self.config.auth_required,\n            password: if self.config.auth_required { Some(self.generate_password()) } else { None },\n            certificate_path: self.config.certificate_path.clone(),\n            websocket_url: if self.config.web_console_enabled {\n                Some(format!(\"ws://localhost:{}/spice/{}\", self.config.web_console_port, session_id))\n            } else {\n                None\n            },\n        };\n\n        let session = ConsoleSession {\n            vm_name: vm_name.to_string(),\n            session_id: session_id.clone(),\n            console_type: ConsoleType::SPICE,\n            connection_info,\n            created_at: chrono::Utc::now(),\n            last_accessed: chrono::Utc::now(),\n            active: true,\n        };\n\n        {\n            let mut sessions = self.sessions.lock().unwrap();\n            sessions.insert(session_id.clone(), session.clone());\n        }\n\n        log_info!(\"SPICE console created successfully: {}:{}\", \"localhost\", port);\n        Ok(session)\n    }\n\n    // RDP Console (For Windows VMs)\n    pub async fn create_rdp_console(&mut self, vm_name: &str, vm_ip: &str) -> Result<ConsoleSession> {\n        log_info!(\"Creating RDP console for VM: {} ({})\", vm_name, vm_ip);\n\n        let port = 3389; // Standard RDP port\n        let session_id = format!(\"rdp-{}-{}\", vm_name, chrono::Utc::now().timestamp());\n\n        let connection_info = ConnectionInfo {\n            host: vm_ip.to_string(),\n            port,\n            protocol: \"rdp\".to_string(),\n            auth_required: true, // RDP always requires auth\n            password: None, // User provides credentials\n            certificate_path: None,\n            websocket_url: if self.config.web_console_enabled {\n                Some(format!(\"ws://localhost:{}/rdp/{}\", self.config.web_console_port, session_id))\n            } else {\n                None\n            },\n        };\n\n        let session = ConsoleSession {\n            vm_name: vm_name.to_string(),\n            session_id: session_id.clone(),\n            console_type: ConsoleType::RDP,\n            connection_info,\n            created_at: chrono::Utc::now(),\n            last_accessed: chrono::Utc::now(),\n            active: true,\n        };\n\n        {\n            let mut sessions = self.sessions.lock().unwrap();\n            sessions.insert(session_id.clone(), session.clone());\n        }\n\n        log_info!(\"RDP console session created: {}:{}\", vm_ip, port);\n        Ok(session)\n    }\n\n    // Serial Console (For headless VMs and debugging)\n    pub async fn create_serial_console(&mut self, vm_name: &str) -> Result<ConsoleSession> {\n        log_info!(\"Creating serial console for VM: {}\", vm_name);\n\n        let session_id = format!(\"serial-{}-{}\", vm_name, chrono::Utc::now().timestamp());\n        \n        // Connect to VM's serial console via virsh or socat\n        let connection_info = ConnectionInfo {\n            host: \"localhost\".to_string(),\n            port: 0, // Serial doesn't use network ports\n            protocol: \"serial\".to_string(),\n            auth_required: false,\n            password: None,\n            certificate_path: None,\n            websocket_url: if self.config.web_console_enabled {\n                Some(format!(\"ws://localhost:{}/serial/{}\", self.config.web_console_port, session_id))\n            } else {\n                None\n            },\n        };\n\n        let session = ConsoleSession {\n            vm_name: vm_name.to_string(),\n            session_id: session_id.clone(),\n            console_type: ConsoleType::SerialConsole,\n            connection_info,\n            created_at: chrono::Utc::now(),\n            last_accessed: chrono::Utc::now(),\n            active: true,\n        };\n\n        {\n            let mut sessions = self.sessions.lock().unwrap();\n            sessions.insert(session_id.clone(), session.clone());\n        }\n\n        log_info!(\"Serial console session created for VM: {}\", vm_name);\n        Ok(session)\n    }\n\n    // Web-based Console (noVNC/HTML5)\n    pub async fn create_web_console(&mut self, vm_name: &str) -> Result<ConsoleSession> {\n        log_info!(\"Creating web console for VM: {}\", vm_name);\n\n        // First create a VNC session\n        let vnc_session = self.create_vnc_console(vm_name, true).await?;\n        \n        let session_id = format!(\"web-{}-{}\", vm_name, chrono::Utc::now().timestamp());\n        \n        // Start noVNC proxy\n        self.start_novnc_proxy(&vnc_session).await?;\n\n        let connection_info = ConnectionInfo {\n            host: \"localhost\".to_string(),\n            port: self.config.web_console_port,\n            protocol: \"https\".to_string(),\n            auth_required: self.config.auth_required,\n            password: vnc_session.connection_info.password,\n            certificate_path: self.config.certificate_path.clone(),\n            websocket_url: Some(format!(\n                \"{}://localhost:{}/websockify?token={}\", \n                if self.config.ssl_enabled { \"wss\" } else { \"ws\" },\n                self.config.web_console_port,\n                session_id\n            )),\n        };\n\n        let session = ConsoleSession {\n            vm_name: vm_name.to_string(),\n            session_id: session_id.clone(),\n            console_type: ConsoleType::WebConsole,\n            connection_info,\n            created_at: chrono::Utc::now(),\n            last_accessed: chrono::Utc::now(),\n            active: true,\n        };\n\n        {\n            let mut sessions = self.sessions.lock().unwrap();\n            sessions.insert(session_id.clone(), session.clone());\n        }\n\n        log_info!(\"Web console created: https://localhost:{}/vnc.html?token={}\", \n                 self.config.web_console_port, session_id);\n        Ok(session)\n    }\n\n    async fn start_novnc_proxy(&self, vnc_session: &ConsoleSession) -> Result<()> {\n        // Start websockify proxy for noVNC\n        let websockify_cmd = Command::new(\"websockify\")\n            .args(&[\n                &format!(\"{}:{}\", self.config.web_console_port, vnc_session.connection_info.port),\n                &format!(\"{}:{}\", vnc_session.connection_info.host, vnc_session.connection_info.port)\n            ])\n            .spawn()\n            .map_err(|e| {\n                log_error!(\"Failed to start websockify: {}\", e);\n                NovaError::SystemCommandFailed\n            })?;\n\n        log_debug!(\"websockify proxy started for VNC session\");\n        Ok(())\n    }\n\n    // Console Session Management\n    pub fn get_console_session(&self, session_id: &str) -> Option<ConsoleSession> {\n        let sessions = self.sessions.lock().unwrap();\n        sessions.get(session_id).cloned()\n    }\n\n    pub fn list_active_sessions(&self) -> Vec<ConsoleSession> {\n        let sessions = self.sessions.lock().unwrap();\n        sessions.values().filter(|s| s.active).cloned().collect()\n    }\n\n    pub async fn close_session(&mut self, session_id: &str) -> Result<()> {\n        log_info!(\"Closing console session: {}\", session_id);\n\n        // Remove from active sessions\n        {\n            let mut sessions = self.sessions.lock().unwrap();\n            if let Some(mut session) = sessions.get_mut(session_id) {\n                session.active = false;\n            }\n        }\n\n        // Kill associated processes\n        if session_id.starts_with(\"vnc-\") {\n            let mut processes = self.vnc_processes.lock().unwrap();\n            if let Some(mut process) = processes.remove(session_id) {\n                let _ = process.kill();\n            }\n        } else if session_id.starts_with(\"spice-\") {\n            let mut processes = self.spice_processes.lock().unwrap();\n            if let Some(mut process) = processes.remove(session_id) {\n                let _ = process.kill();\n            }\n        }\n\n        // Release allocated port\n        if let Some(session) = self.get_console_session(session_id) {\n            self.release_port(session.console_type, session.connection_info.port);\n        }\n\n        Ok(())\n    }\n\n    // Enhanced Console Features\n    pub async fn enable_clipboard_sharing(&self, session_id: &str) -> Result<()> {\n        log_info!(\"Enabling clipboard sharing for session: {}\", session_id);\n        // SPICE supports this natively, VNC needs additional setup\n        Ok(())\n    }\n\n    pub async fn enable_usb_redirection(&self, session_id: &str, device_id: &str) -> Result<()> {\n        log_info!(\"Enabling USB redirection for session: {} device: {}\", session_id, device_id);\n        // Requires SPICE and proper USB passthrough configuration\n        Ok(())\n    }\n\n    pub async fn set_display_resolution(&self, session_id: &str, width: u32, height: u32) -> Result<()> {\n        log_info!(\"Setting display resolution for session: {} to {}x{}\", session_id, width, height);\n        \n        if let Some(session) = self.get_console_session(session_id) {\n            match session.console_type {\n                ConsoleType::SPICE => {\n                    // SPICE supports dynamic resolution changes\n                    // Send resolution change command to guest agent\n                    self.send_guest_agent_command(&session.vm_name, \n                        &format!(\"display-set-resolution width={} height={}\", width, height)).await?;\n                }\n                ConsoleType::VNC => {\n                    // VNC resolution is more limited\n                    log_warn!(\"VNC resolution changes require guest cooperation\");\n                }\n                _ => {\n                    log_warn!(\"Resolution change not supported for this console type\");\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn send_guest_agent_command(&self, vm_name: &str, command: &str) -> Result<()> {\n        let output = Command::new(\"virsh\")\n            .args(&[\"qemu-agent-command\", vm_name, &format!(\"{{\\\"execute\\\":\\\"{}\\\"}}\", command)])\n            .output()\n            .map_err(|_| NovaError::SystemCommandFailed)?;\n\n        if !output.status.success() {\n            log_error!(\"Failed to send guest agent command: {}\", String::from_utf8_lossy(&output.stderr));\n            return Err(NovaError::SystemCommandFailed);\n        }\n\n        Ok(())\n    }\n\n    // Multi-monitor support\n    pub async fn configure_multi_monitor(&self, session_id: &str, monitor_count: u32) -> Result<()> {\n        log_info!(\"Configuring {} monitors for session: {}\", monitor_count, session_id);\n        \n        if let Some(session) = self.get_console_session(session_id) {\n            if matches!(session.console_type, ConsoleType::SPICE) {\n                // SPICE supports multi-monitor natively\n                self.send_guest_agent_command(&session.vm_name, \n                    &format!(\"display-set-monitors count={}\", monitor_count)).await?;\n            } else {\n                log_warn!(\"Multi-monitor support requires SPICE console\");\n            }\n        }\n\n        Ok(())\n    }\n\n    // Performance optimization\n    pub async fn optimize_console_performance(&self, session_id: &str) -> Result<()> {\n        log_info!(\"Optimizing console performance for session: {}\", session_id);\n        \n        if let Some(session) = self.get_console_session(session_id) {\n            match session.console_type {\n                ConsoleType::SPICE => {\n                    // Enable SPICE optimizations:\n                    // - Image compression\n                    // - Video streaming\n                    // - Audio compression\n                    log_info!(\"SPICE optimizations enabled for session: {}\", session_id);\n                }\n                ConsoleType::VNC => {\n                    // Enable VNC optimizations:\n                    // - Tight encoding\n                    // - Zlib compression\n                    // - JPEG quality adjustment\n                    log_info!(\"VNC optimizations enabled for session: {}\", session_id);\n                }\n                _ => {}\n            }\n        }\n\n        Ok(())\n    }\n\n    // Port management\n    fn allocate_port(&mut self, console_type: ConsoleType) -> Result<u16> {\n        let mut allocator = self.port_allocator.lock().unwrap();\n        \n        let port = match console_type {\n            ConsoleType::VNC => allocator.vnc_ports.pop_front(),\n            ConsoleType::SPICE => allocator.spice_ports.pop_front(),\n            ConsoleType::RDP => allocator.rdp_ports.pop_front(),\n            _ => None,\n        };\n\n        match port {\n            Some(p) => {\n                allocator.allocated_ports.insert(p);\n                Ok(p)\n            }\n            None => {\n                log_error!(\"No available ports for console type: {:?}\", console_type);\n                Err(NovaError::SystemCommandFailed)\n            }\n        }\n    }\n\n    fn release_port(&mut self, console_type: ConsoleType, port: u16) {\n        let mut allocator = self.port_allocator.lock().unwrap();\n        \n        allocator.allocated_ports.remove(&port);\n        \n        match console_type {\n            ConsoleType::VNC => allocator.vnc_ports.push_back(port),\n            ConsoleType::SPICE => allocator.spice_ports.push_back(port),\n            ConsoleType::RDP => allocator.rdp_ports.push_back(port),\n            _ => {}\n        }\n    }\n\n    // Utility functions\n    fn check_spice_available(&self) -> bool {\n        Command::new(\"spice-server\")\n            .arg(\"--version\")\n            .output()\n            .map(|output| output.status.success())\n            .unwrap_or(false)\n    }\n\n    fn check_novnc_available(&self) -> bool {\n        Command::new(\"websockify\")\n            .arg(\"--version\")\n            .output()\n            .map(|output| output.status.success())\n            .unwrap_or(false)\n    }\n\n    fn generate_password(&self) -> String {\n        use rand::Rng;\n        const CHARSET: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                abcdefghijklmnopqrstuvwxyz\\\n                                0123456789\";\n        const PASSWORD_LEN: usize = 12;\n        let mut rng = rand::thread_rng();\n\n        (0..PASSWORD_LEN)\n            .map(|_| {\n                let idx = rng.gen_range(0..CHARSET.len());\n                CHARSET[idx] as char\n            })\n            .collect()\n    }\n\n    // Session cleanup\n    pub async fn cleanup_inactive_sessions(&mut self) {\n        let cutoff = chrono::Utc::now() - chrono::Duration::hours(24);\n        \n        let mut to_remove = Vec::new();\n        {\n            let sessions = self.sessions.lock().unwrap();\n            for (id, session) in sessions.iter() {\n                if !session.active || session.last_accessed < cutoff {\n                    to_remove.push(id.clone());\n                }\n            }\n        }\n\n        for session_id in to_remove {\n            let _ = self.close_session(&session_id).await;\n        }\n\n        log_info!(\"Cleaned up {} inactive console sessions\", to_remove.len());\n    }\n}\n\nimpl Default for ConsoleConfig {\n    fn default() -> Self {\n        Self {\n            vnc_enabled: true,\n            vnc_port_range: (5900, 5999),\n            spice_enabled: true,\n            spice_port_range: (5000, 5099),\n            rdp_enabled: true,\n            rdp_port_range: (3389, 3389),\n            web_console_enabled: true,\n            web_console_port: 6080,\n            auth_required: true,\n            ssl_enabled: false,\n            certificate_path: None,\n            key_path: None,\n        }\n    }\n}"