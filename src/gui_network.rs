use crate::network::{NetworkManager, VirtualSwitch, SwitchType, NetworkInterface, BridgeConfig, DhcpConfig, NatConfig};\nuse crate::libvirt::{LibvirtManager, LibvirtNetwork};\nuse crate::monitoring::{NetworkMonitor, NetworkTopology, PacketCaptureConfig, BandwidthUsage};\nuse crate::arch_integration::{ArchNetworkManager, ArchNetworkConfig};\nuse crate::{log_info, log_error, Result};\n\nuse eframe::egui;\nuse egui::{Color32, Stroke, Vec2, Pos2, Rect};\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\n\npub struct NetworkingGui {\n    // Core managers\n    network_manager: Arc<Mutex<NetworkManager>>,\n    libvirt_manager: Arc<Mutex<LibvirtManager>>,\n    network_monitor: Arc<Mutex<NetworkMonitor>>,\n    arch_manager: Arc<Mutex<ArchNetworkManager>>,\n    \n    // GUI state\n    selected_tab: NetworkTab,\n    switch_creation_dialog: SwitchCreationDialog,\n    network_creation_dialog: NetworkCreationDialog,\n    monitoring_enabled: bool,\n    capture_dialog: CaptureDialog,\n    topology_view: TopologyView,\n    \n    // Data\n    switches: Vec<VirtualSwitch>,\n    libvirt_networks: Vec<LibvirtNetwork>,\n    interfaces: Vec<NetworkInterface>,\n    topology: Option<NetworkTopology>,\n    bandwidth_data: HashMap<String, Vec<BandwidthUsage>>,\n}\n\n#[derive(Debug, Clone, PartialEq)]\nenum NetworkTab {\n    Overview,\n    VirtualSwitches,\n    LibvirtNetworks,\n    Monitoring,\n    Topology,\n    PacketCapture,\n    ArchConfig,\n}\n\n#[derive(Debug, Clone)]\nstruct SwitchCreationDialog {\n    show: bool,\n    name: String,\n    switch_type: SwitchType,\n    interfaces: Vec<String>,\n    selected_interfaces: Vec<bool>,\n    enable_stp: bool,\n    vlan_id: String,\n}\n\n#[derive(Debug, Clone)]\nstruct NetworkCreationDialog {\n    show: bool,\n    name: String,\n    network_type: String,\n    subnet: String,\n    gateway: String,\n    dhcp_enabled: bool,\n    dhcp_start: String,\n    dhcp_end: String,\n    autostart: bool,\n}\n\n#[derive(Debug, Clone)]\nstruct CaptureDialog {\n    show: bool,\n    interface: String,\n    filter: String,\n    duration: String,\n    packet_count: String,\n    output_file: String,\n    active_captures: Vec<String>,\n}\n\n#[derive(Debug, Clone)]\nstruct TopologyView {\n    zoom: f32,\n    pan_offset: Vec2,\n    selected_node: Option<String>,\n    node_positions: HashMap<String, Pos2>,\n}\n\nimpl NetworkingGui {\n    pub fn new() -> Self {\n        Self {\n            network_manager: Arc::new(Mutex::new(NetworkManager::new())),\n            libvirt_manager: Arc::new(Mutex::new(LibvirtManager::new())),\n            network_monitor: Arc::new(Mutex::new(NetworkMonitor::new())),\n            arch_manager: Arc::new(Mutex::new(ArchNetworkManager::new())),\n            \n            selected_tab: NetworkTab::Overview,\n            switch_creation_dialog: SwitchCreationDialog {\n                show: false,\n                name: String::new(),\n                switch_type: SwitchType::LinuxBridge,\n                interfaces: Vec::new(),\n                selected_interfaces: Vec::new(),\n                enable_stp: false,\n                vlan_id: String::new(),\n            },\n            network_creation_dialog: NetworkCreationDialog {\n                show: false,\n                name: String::new(),\n                network_type: \"NAT\".to_string(),\n                subnet: \"192.168.100.0/24\".to_string(),\n                gateway: \"192.168.100.1\".to_string(),\n                dhcp_enabled: true,\n                dhcp_start: \"192.168.100.2\".to_string(),\n                dhcp_end: \"192.168.100.254\".to_string(),\n                autostart: true,\n            },\n            monitoring_enabled: false,\n            capture_dialog: CaptureDialog {\n                show: false,\n                interface: String::new(),\n                filter: String::new(),\n                duration: \"60\".to_string(),\n                packet_count: \"1000\".to_string(),\n                output_file: \"/tmp/nova-capture.pcap\".to_string(),\n                active_captures: Vec::new(),\n            },\n            topology_view: TopologyView {\n                zoom: 1.0,\n                pan_offset: Vec2::ZERO,\n                selected_node: None,\n                node_positions: HashMap::new(),\n            },\n            \n            switches: Vec::new(),\n            libvirt_networks: Vec::new(),\n            interfaces: Vec::new(),\n            topology: None,\n            bandwidth_data: HashMap::new(),\n        }\n    }\n\n    pub fn show(&mut self, ctx: &egui::Context) {\n        egui::CentralPanel::default().show(ctx, |ui| {\n            ui.horizontal(|ui| {\n                ui.selectable_value(&mut self.selected_tab, NetworkTab::Overview, \"Overview\");\n                ui.selectable_value(&mut self.selected_tab, NetworkTab::VirtualSwitches, \"Virtual Switches\");\n                ui.selectable_value(&mut self.selected_tab, NetworkTab::LibvirtNetworks, \"Libvirt Networks\");\n                ui.selectable_value(&mut self.selected_tab, NetworkTab::Monitoring, \"Monitoring\");\n                ui.selectable_value(&mut self.selected_tab, NetworkTab::Topology, \"Topology\");\n                ui.selectable_value(&mut self.selected_tab, NetworkTab::PacketCapture, \"Packet Capture\");\n                ui.selectable_value(&mut self.selected_tab, NetworkTab::ArchConfig, \"Arch Config\");\n            });\n\n            ui.separator();\n\n            match self.selected_tab {\n                NetworkTab::Overview => self.show_overview(ui),\n                NetworkTab::VirtualSwitches => self.show_virtual_switches(ui),\n                NetworkTab::LibvirtNetworks => self.show_libvirt_networks(ui),\n                NetworkTab::Monitoring => self.show_monitoring(ui),\n                NetworkTab::Topology => self.show_topology(ui),\n                NetworkTab::PacketCapture => self.show_packet_capture(ui),\n                NetworkTab::ArchConfig => self.show_arch_config(ui),\n            }\n        });\n\n        // Show dialogs\n        self.show_switch_creation_dialog(ctx);\n        self.show_network_creation_dialog(ctx);\n        self.show_capture_dialog(ctx);\n    }\n\n    fn show_overview(&mut self, ui: &mut egui::Ui) {\n        ui.heading(\"Network Overview\");\n        \n        ui.horizontal(|ui| {\n            // Quick stats\n            egui::Frame::none()\n                .fill(Color32::from_gray(40))\n                .rounding(5.0)\n                .inner_margin(10.0)\n                .show(ui, |ui| {\n                    ui.vertical(|ui| {\n                        ui.label(\"Virtual Switches\");\n                        ui.heading(self.switches.len().to_string());\n                    });\n                });\n\n            egui::Frame::none()\n                .fill(Color32::from_gray(40))\n                .rounding(5.0)\n                .inner_margin(10.0)\n                .show(ui, |ui| {\n                    ui.vertical(|ui| {\n                        ui.label(\"Libvirt Networks\");\n                        ui.heading(self.libvirt_networks.len().to_string());\n                    });\n                });\n\n            egui::Frame::none()\n                .fill(Color32::from_gray(40))\n                .rounding(5.0)\n                .inner_margin(10.0)\n                .show(ui, |ui| {\n                    ui.vertical(|ui| {\n                        ui.label(\"Network Interfaces\");\n                        ui.heading(self.interfaces.len().to_string());\n                    });\n                });\n        });\n\n        ui.separator();\n\n        // Quick actions\n        ui.heading(\"Quick Actions\");\n        ui.horizontal(|ui| {\n            if ui.button(\"Create Virtual Switch\").clicked() {\n                self.switch_creation_dialog.show = true;\n                self.refresh_interfaces();\n            }\n            if ui.button(\"Create Libvirt Network\").clicked() {\n                self.network_creation_dialog.show = true;\n            }\n            if ui.button(\"Refresh All\").clicked() {\n                self.refresh_all_data();\n            }\n        });\n\n        ui.separator();\n\n        // Recent activity\n        ui.heading(\"Network Status\");\n        egui::ScrollArea::vertical().show(ui, |ui| {\n            for interface in &self.interfaces {\n                ui.horizontal(|ui| {\n                    let color = match interface.state {\n                        crate::network::InterfaceState::Up => Color32::GREEN,\n                        crate::network::InterfaceState::Down => Color32::RED,\n                        crate::network::InterfaceState::Unknown => Color32::YELLOW,\n                    };\n                    \n                    ui.colored_label(color, \"‚óè\");\n                    ui.label(&interface.name);\n                    ui.label(&interface.mac_address);\n                    if let Some(ip) = interface.ip_address {\n                        ui.label(ip.to_string());\n                    }\n                });\n            }\n        });\n    }\n\n    fn show_virtual_switches(&mut self, ui: &mut egui::Ui) {\n        ui.horizontal(|ui| {\n            ui.heading(\"Virtual Switches\");\n            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {\n                if ui.button(\"+ Create Switch\").clicked() {\n                    self.switch_creation_dialog.show = true;\n                    self.refresh_interfaces();\n                }\n                if ui.button(\"üîÑ Refresh\").clicked() {\n                    self.refresh_switches();\n                }\n            });\n        });\n\n        ui.separator();\n\n        egui::ScrollArea::vertical().show(ui, |ui| {\n            for switch in &self.switches {\n                egui::Frame::none()\n                    .fill(Color32::from_gray(30))\n                    .rounding(5.0)\n                    .inner_margin(10.0)\n                    .show(ui, |ui| {\n                        ui.horizontal(|ui| {\n                            ui.vertical(|ui| {\n                                ui.heading(&switch.name);\n                                ui.label(format!(\"Type: {:?}\", switch.switch_type));\n                                ui.label(format!(\"Interfaces: {}\", switch.interfaces.len()));\n                                ui.label(format!(\"Status: {:?}\", switch.status));\n                                if let Some(vlan) = switch.vlan_id {\n                                    ui.label(format!(\"VLAN: {}\", vlan));\n                                }\n                                ui.label(format!(\"STP: {}\", if switch.stp_enabled { \"Enabled\" } else { \"Disabled\" }));\n                            });\n                            \n                            ui.with_layout(egui::Layout::right_to_left(egui::Align::Top), |ui| {\n                                if ui.button(\"‚öôÔ∏è Configure\").clicked() {\n                                    // Open configuration dialog\n                                }\n                                if ui.button(\"üóëÔ∏è Delete\").clicked() {\n                                    self.delete_switch(&switch.name);\n                                }\n                            });\n                        });\n                        \n                        if !switch.interfaces.is_empty() {\n                            ui.separator();\n                            ui.label(\"Attached Interfaces:\");\n                            for interface in &switch.interfaces {\n                                ui.label(format!(\"  ‚Ä¢ {}\", interface));\n                            }\n                        }\n                    });\n                ui.add_space(5.0);\n            }\n        });\n    }\n\n    fn show_libvirt_networks(&mut self, ui: &mut egui::Ui) {\n        ui.horizontal(|ui| {\n            ui.heading(\"Libvirt Networks\");\n            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {\n                if ui.button(\"+ Create Network\").clicked() {\n                    self.network_creation_dialog.show = true;\n                }\n                if ui.button(\"üîÑ Refresh\").clicked() {\n                    self.refresh_libvirt_networks();\n                }\n            });\n        });\n\n        ui.separator();\n\n        egui::ScrollArea::vertical().show(ui, |ui| {\n            for network in &self.libvirt_networks {\n                egui::Frame::none()\n                    .fill(Color32::from_gray(30))\n                    .rounding(5.0)\n                    .inner_margin(10.0)\n                    .show(ui, |ui| {\n                        ui.horizontal(|ui| {\n                            ui.vertical(|ui| {\n                                ui.heading(&network.name);\n                                if let Some(uuid) = &network.uuid {\n                                    ui.label(format!(\"UUID: {}\", uuid));\n                                }\n                                ui.label(format!(\"Active: {}\", network.active));\n                                ui.label(format!(\"Autostart: {}\", network.autostart));\n                                \n                                if let Some(forward) = &network.forward {\n                                    ui.label(format!(\"Forward Mode: {}\", forward.mode));\n                                }\n                                \n                                if let Some(ip) = &network.ip {\n                                    ui.label(format!(\"Network: {}/{}\", ip.address, ip.netmask));\n                                    if let Some(dhcp) = &ip.dhcp {\n                                        ui.label(format!(\"DHCP Range: {} - {}\", dhcp.start, dhcp.end));\n                                    }\n                                }\n                            });\n                            \n                            ui.with_layout(egui::Layout::right_to_left(egui::Align::Top), |ui| {\n                                let action_text = if network.active { \"‚èπÔ∏è Stop\" } else { \"‚ñ∂Ô∏è Start\" };\n                                if ui.button(action_text).clicked() {\n                                    self.toggle_libvirt_network(&network.name, network.active);\n                                }\n                                if ui.button(\"‚öôÔ∏è Edit\").clicked() {\n                                    // Open edit dialog\n                                }\n                                if ui.button(\"üóëÔ∏è Delete\").clicked() {\n                                    self.delete_libvirt_network(&network.name);\n                                }\n                            });\n                        });\n                    });\n                ui.add_space(5.0);\n            }\n        });\n    }\n\n    fn show_monitoring(&mut self, ui: &mut egui::Ui) {\n        ui.horizontal(|ui| {\n            ui.heading(\"Network Monitoring\");\n            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {\n                let button_text = if self.monitoring_enabled { \"‚èπÔ∏è Stop Monitoring\" } else { \"‚ñ∂Ô∏è Start Monitoring\" };\n                if ui.button(button_text).clicked() {\n                    self.toggle_monitoring();\n                }\n            });\n        });\n\n        ui.separator();\n\n        if !self.monitoring_enabled {\n            ui.centered_and_justified(|ui| {\n                ui.label(\"Click 'Start Monitoring' to begin collecting network statistics\");\n            });\n            return;\n        }\n\n        // Bandwidth charts\n        for (interface, bandwidth_history) in &self.bandwidth_data {\n            if bandwidth_history.is_empty() {\n                continue;\n            }\n\n            egui::Frame::none()\n                .fill(Color32::from_gray(30))\n                .rounding(5.0)\n                .inner_margin(10.0)\n                .show(ui, |ui| {\n                    ui.heading(format!(\"Interface: {}\", interface));\n                    \n                    // Show current bandwidth\n                    if let Some(latest) = bandwidth_history.last() {\n                        ui.horizontal(|ui| {\n                            ui.label(format!(\"RX: {:.2} MB/s\", latest.rx_bps / 1024.0 / 1024.0));\n                            ui.label(format!(\"TX: {:.2} MB/s\", latest.tx_bps / 1024.0 / 1024.0));\n                        });\n                    }\n                    \n                    // Simple bandwidth chart (would be more sophisticated in real implementation)\n                    let available_rect = ui.available_rect_before_wrap();\n                    let chart_rect = Rect::from_min_size(available_rect.min, Vec2::new(available_rect.width(), 100.0));\n                    \n                    ui.painter().rect_filled(chart_rect, 2.0, Color32::from_gray(20));\n                    \n                    // Draw bandwidth lines\n                    if bandwidth_history.len() > 1 {\n                        let max_bps = bandwidth_history.iter()\n                            .map(|b| b.rx_bps.max(b.tx_bps))\n                            .fold(0.0, f64::max);\n                        \n                        if max_bps > 0.0 {\n                            let points_rx: Vec<Pos2> = bandwidth_history.iter().enumerate()\n                                .map(|(i, b)| {\n                                    let x = chart_rect.min.x + (i as f32 / bandwidth_history.len() as f32) * chart_rect.width();\n                                    let y = chart_rect.max.y - (b.rx_bps / max_bps) as f32 * chart_rect.height();\n                                    Pos2::new(x, y)\n                                })\n                                .collect();\n                            \n                            let points_tx: Vec<Pos2> = bandwidth_history.iter().enumerate()\n                                .map(|(i, b)| {\n                                    let x = chart_rect.min.x + (i as f32 / bandwidth_history.len() as f32) * chart_rect.width();\n                                    let y = chart_rect.max.y - (b.tx_bps / max_bps) as f32 * chart_rect.height();\n                                    Pos2::new(x, y)\n                                })\n                                .collect();\n                            \n                            // Draw RX line in green\n                            for window in points_rx.windows(2) {\n                                ui.painter().line_segment([window[0], window[1]], Stroke::new(2.0, Color32::GREEN));\n                            }\n                            \n                            // Draw TX line in blue\n                            for window in points_tx.windows(2) {\n                                ui.painter().line_segment([window[0], window[1]], Stroke::new(2.0, Color32::BLUE));\n                            }\n                        }\n                    }\n                    \n                    ui.allocate_space(Vec2::new(chart_rect.width(), chart_rect.height()));\n                });\n            ui.add_space(10.0);\n        }\n    }\n\n    fn show_topology(&mut self, ui: &mut egui::Ui) {\n        ui.horizontal(|ui| {\n            ui.heading(\"Network Topology\");\n            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {\n                if ui.button(\"üîÑ Refresh\").clicked() {\n                    self.refresh_topology();\n                }\n            });\n        });\n\n        ui.separator();\n\n        if let Some(topology) = &self.topology {\n            let available_rect = ui.available_rect_before_wrap();\n            \n            ui.painter().rect_filled(available_rect, 2.0, Color32::from_gray(20));\n            \n            // Draw bridges\n            let mut bridge_positions = HashMap::new();\n            for (i, bridge) in topology.bridges.iter().enumerate() {\n                let x = available_rect.min.x + 100.0 + (i as f32) * 200.0;\n                let y = available_rect.min.y + 100.0;\n                let pos = Pos2::new(x, y);\n                bridge_positions.insert(bridge.name.clone(), pos);\n                \n                // Draw bridge node\n                let color = match bridge.bridge_type.as_str() {\n                    \"linux\" => Color32::BLUE,\n                    \"ovs\" => Color32::GREEN,\n                    _ => Color32::GRAY,\n                };\n                \n                ui.painter().circle_filled(pos, 30.0, color);\n                ui.painter().text(\n                    pos,\n                    egui::Align2::CENTER_CENTER,\n                    &bridge.name,\n                    egui::FontId::default(),\n                    Color32::WHITE,\n                );\n                \n                // Draw interfaces connected to bridge\n                for (j, interface) in bridge.interfaces.iter().enumerate() {\n                    let iface_x = x;\n                    let iface_y = y + 80.0 + (j as f32) * 30.0;\n                    let iface_pos = Pos2::new(iface_x, iface_y);\n                    \n                    ui.painter().circle_filled(iface_pos, 15.0, Color32::YELLOW);\n                    ui.painter().text(\n                        iface_pos + Vec2::new(20.0, 0.0),\n                        egui::Align2::LEFT_CENTER,\n                        interface,\n                        egui::FontId::default(),\n                        Color32::WHITE,\n                    );\n                    \n                    // Draw connection line\n                    ui.painter().line_segment([pos, iface_pos], Stroke::new(2.0, Color32::WHITE));\n                }\n            }\n        } else {\n            ui.centered_and_justified(|ui| {\n                ui.label(\"Click 'Refresh' to discover network topology\");\n            });\n        }\n    }\n\n    fn show_packet_capture(&mut self, ui: &mut egui::Ui) {\n        ui.horizontal(|ui| {\n            ui.heading(\"Packet Capture\");\n            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {\n                if ui.button(\"+ New Capture\").clicked() {\n                    self.capture_dialog.show = true;\n                }\n            });\n        });\n\n        ui.separator();\n\n        // Active captures\n        if !self.capture_dialog.active_captures.is_empty() {\n            ui.heading(\"Active Captures\");\n            for capture_id in &self.capture_dialog.active_captures.clone() {\n                ui.horizontal(|ui| {\n                    ui.label(capture_id);\n                    if ui.button(\"‚èπÔ∏è Stop\").clicked() {\n                        self.stop_capture(capture_id);\n                    }\n                });\n            }\n            ui.separator();\n        }\n\n        // Capture files\n        ui.heading(\"Capture Files\");\n        ui.label(\"Recent packet capture files will be listed here\");\n        \n        // Would list actual .pcap files in a real implementation\n        ui.horizontal(|ui| {\n            ui.label(\"/tmp/nova-capture.pcap\");\n            if ui.button(\"üîç Open in Wireshark\").clicked() {\n                self.open_in_wireshark(\"/tmp/nova-capture.pcap\");\n            }\n        });\n    }\n\n    fn show_arch_config(&mut self, ui: &mut egui::Ui) {\n        ui.heading(\"Arch Linux Configuration\");\n        \n        ui.separator();\n        \n        // Network manager detection\n        ui.heading(\"Network Management\");\n        ui.label(\"Detected network management systems:\");\n        \n        // Would show actual detection results in real implementation\n        ui.horizontal(|ui| {\n            ui.label(\"‚óè systemd-networkd:\");\n            ui.colored_label(Color32::GREEN, \"Active\");\n        });\n        ui.horizontal(|ui| {\n            ui.label(\"‚óè NetworkManager:\");\n            ui.colored_label(Color32::RED, \"Inactive\");\n        });\n        \n        ui.separator();\n        \n        // KVM optimization\n        ui.heading(\"Virtualization Optimization\");\n        if ui.button(\"Apply Arch Linux KVM Optimizations\").clicked() {\n            self.apply_arch_optimizations();\n        }\n        \n        ui.label(\"This will:\");\n        ui.label(\"‚Ä¢ Load required KVM kernel modules\");\n        ui.label(\"‚Ä¢ Configure systemd for virtualization\");\n        ui.label(\"‚Ä¢ Set up user groups for KVM access\");\n        ui.label(\"‚Ä¢ Optimize network settings for bridges\");\n    }\n\n    // Dialog implementations\n    fn show_switch_creation_dialog(&mut self, ctx: &egui::Context) {\n        if !self.switch_creation_dialog.show {\n            return;\n        }\n\n        egui::Window::new(\"Create Virtual Switch\")\n            .collapsible(false)\n            .resizable(false)\n            .show(ctx, |ui| {\n                ui.horizontal(|ui| {\n                    ui.label(\"Name:\");\n                    ui.text_edit_singleline(&mut self.switch_creation_dialog.name);\n                });\n\n                ui.horizontal(|ui| {\n                    ui.label(\"Type:\");\n                    egui::ComboBox::from_label(\"\")\n                        .selected_text(format!(\"{:?}\", self.switch_creation_dialog.switch_type))\n                        .show_ui(ui, |ui| {\n                            ui.selectable_value(&mut self.switch_creation_dialog.switch_type, SwitchType::LinuxBridge, \"Linux Bridge\");\n                            ui.selectable_value(&mut self.switch_creation_dialog.switch_type, SwitchType::OpenVSwitch, \"Open vSwitch\");\n                        });\n                });\n\n                ui.checkbox(&mut self.switch_creation_dialog.enable_stp, \"Enable STP\");\n\n                ui.horizontal(|ui| {\n                    ui.label(\"VLAN ID (optional):\");\n                    ui.text_edit_singleline(&mut self.switch_creation_dialog.vlan_id);\n                });\n\n                ui.label(\"Select interfaces to add:\");\n                egui::ScrollArea::vertical().max_height(100.0).show(ui, |ui| {\n                    for (i, interface) in self.switch_creation_dialog.interfaces.iter().enumerate() {\n                        if i >= self.switch_creation_dialog.selected_interfaces.len() {\n                            self.switch_creation_dialog.selected_interfaces.push(false);\n                        }\n                        ui.checkbox(&mut self.switch_creation_dialog.selected_interfaces[i], interface);\n                    }\n                });\n\n                ui.separator();\n\n                ui.horizontal(|ui| {\n                    if ui.button(\"Create\").clicked() {\n                        self.create_switch();\n                        self.switch_creation_dialog.show = false;\n                    }\n                    if ui.button(\"Cancel\").clicked() {\n                        self.switch_creation_dialog.show = false;\n                    }\n                });\n            });\n    }\n\n    fn show_network_creation_dialog(&mut self, ctx: &egui::Context) {\n        if !self.network_creation_dialog.show {\n            return;\n        }\n\n        egui::Window::new(\"Create Libvirt Network\")\n            .collapsible(false)\n            .resizable(false)\n            .show(ctx, |ui| {\n                ui.horizontal(|ui| {\n                    ui.label(\"Name:\");\n                    ui.text_edit_singleline(&mut self.network_creation_dialog.name);\n                });\n\n                ui.horizontal(|ui| {\n                    ui.label(\"Type:\");\n                    egui::ComboBox::from_label(\"\")\n                        .selected_text(&self.network_creation_dialog.network_type)\n                        .show_ui(ui, |ui| {\n                            ui.selectable_value(&mut self.network_creation_dialog.network_type, \"NAT\".to_string(), \"NAT\");\n                            ui.selectable_value(&mut self.network_creation_dialog.network_type, \"Bridge\".to_string(), \"Bridge\");\n                            ui.selectable_value(&mut self.network_creation_dialog.network_type, \"Isolated\".to_string(), \"Isolated\");\n                        });\n                });\n\n                ui.horizontal(|ui| {\n                    ui.label(\"Subnet:\");\n                    ui.text_edit_singleline(&mut self.network_creation_dialog.subnet);\n                });\n\n                ui.horizontal(|ui| {\n                    ui.label(\"Gateway:\");\n                    ui.text_edit_singleline(&mut self.network_creation_dialog.gateway);\n                });\n\n                ui.checkbox(&mut self.network_creation_dialog.dhcp_enabled, \"Enable DHCP\");\n\n                if self.network_creation_dialog.dhcp_enabled {\n                    ui.horizontal(|ui| {\n                        ui.label(\"DHCP Start:\");\n                        ui.text_edit_singleline(&mut self.network_creation_dialog.dhcp_start);\n                    });\n                    ui.horizontal(|ui| {\n                        ui.label(\"DHCP End:\");\n                        ui.text_edit_singleline(&mut self.network_creation_dialog.dhcp_end);\n                    });\n                }\n\n                ui.checkbox(&mut self.network_creation_dialog.autostart, \"Autostart\");\n\n                ui.separator();\n\n                ui.horizontal(|ui| {\n                    if ui.button(\"Create\").clicked() {\n                        self.create_libvirt_network();\n                        self.network_creation_dialog.show = false;\n                    }\n                    if ui.button(\"Cancel\").clicked() {\n                        self.network_creation_dialog.show = false;\n                    }\n                });\n            });\n    }\n\n    fn show_capture_dialog(&mut self, ctx: &egui::Context) {\n        if !self.capture_dialog.show {\n            return;\n        }\n\n        egui::Window::new(\"Start Packet Capture\")\n            .collapsible(false)\n            .resizable(false)\n            .show(ctx, |ui| {\n                ui.horizontal(|ui| {\n                    ui.label(\"Interface:\");\n                    ui.text_edit_singleline(&mut self.capture_dialog.interface);\n                });\n\n                ui.horizontal(|ui| {\n                    ui.label(\"Filter (BPF):\");\n                    ui.text_edit_singleline(&mut self.capture_dialog.filter);\n                });\n\n                ui.horizontal(|ui| {\n                    ui.label(\"Duration (seconds):\");\n                    ui.text_edit_singleline(&mut self.capture_dialog.duration);\n                });\n\n                ui.horizontal(|ui| {\n                    ui.label(\"Packet Count:\");\n                    ui.text_edit_singleline(&mut self.capture_dialog.packet_count);\n                });\n\n                ui.horizontal(|ui| {\n                    ui.label(\"Output File:\");\n                    ui.text_edit_singleline(&mut self.capture_dialog.output_file);\n                });\n\n                ui.separator();\n\n                ui.horizontal(|ui| {\n                    if ui.button(\"Start Capture\").clicked() {\n                        self.start_capture();\n                        self.capture_dialog.show = false;\n                    }\n                    if ui.button(\"Cancel\").clicked() {\n                        self.capture_dialog.show = false;\n                    }\n                });\n            });\n    }\n\n    // Action implementations (these would contain actual async calls in a real implementation)\n    fn refresh_all_data(&mut self) {\n        log_info!(\"Refreshing all network data\");\n        // Would call actual refresh methods\n    }\n\n    fn refresh_interfaces(&mut self) {\n        // Populate interfaces for switch creation dialog\n        self.switch_creation_dialog.interfaces = vec![\n            \"eth0\".to_string(),\n            \"eth1\".to_string(),\n            \"wlan0\".to_string(),\n        ];\n        self.switch_creation_dialog.selected_interfaces.clear();\n    }\n\n    fn refresh_switches(&mut self) {\n        log_info!(\"Refreshing virtual switches\");\n        // Would call network_manager.list_switches()\n    }\n\n    fn refresh_libvirt_networks(&mut self) {\n        log_info!(\"Refreshing libvirt networks\");\n        // Would call libvirt_manager.discover_networks()\n    }\n\n    fn refresh_topology(&mut self) {\n        log_info!(\"Refreshing network topology\");\n        // Would call network_monitor.discover_topology()\n    }\n\n    fn create_switch(&mut self) {\n        log_info!(\"Creating virtual switch: {}\", self.switch_creation_dialog.name);\n        // Would call network_manager.create_virtual_switch()\n    }\n\n    fn delete_switch(&mut self, name: &str) {\n        log_info!(\"Deleting virtual switch: {}\", name);\n        // Would call network_manager.delete_virtual_switch()\n    }\n\n    fn create_libvirt_network(&mut self) {\n        log_info!(\"Creating libvirt network: {}\", self.network_creation_dialog.name);\n        // Would call libvirt_manager.create_network()\n    }\n\n    fn delete_libvirt_network(&mut self, name: &str) {\n        log_info!(\"Deleting libvirt network: {}\", name);\n        // Would call libvirt_manager.delete_network()\n    }\n\n    fn toggle_libvirt_network(&mut self, name: &str, currently_active: bool) {\n        if currently_active {\n            log_info!(\"Stopping libvirt network: {}\", name);\n            // Would call libvirt_manager.stop_network()\n        } else {\n            log_info!(\"Starting libvirt network: {}\", name);\n            // Would call libvirt_manager.start_network()\n        }\n    }\n\n    fn toggle_monitoring(&mut self) {\n        self.monitoring_enabled = !self.monitoring_enabled;\n        if self.monitoring_enabled {\n            log_info!(\"Starting network monitoring\");\n            // Would call network_monitor.start_monitoring()\n        } else {\n            log_info!(\"Stopping network monitoring\");\n            // Would call network_monitor.stop_monitoring()\n        }\n    }\n\n    fn start_capture(&mut self) {\n        log_info!(\"Starting packet capture on {}\", self.capture_dialog.interface);\n        // Would call network_monitor.start_packet_capture()\n        // Add to active captures list\n        self.capture_dialog.active_captures.push(format!(\"capture-{}\", self.capture_dialog.interface));\n    }\n\n    fn stop_capture(&mut self, capture_id: &str) {\n        log_info!(\"Stopping packet capture: {}\", capture_id);\n        // Would call network_monitor.stop_packet_capture()\n        self.capture_dialog.active_captures.retain(|id| id != capture_id);\n    }\n\n    fn open_in_wireshark(&mut self, file_path: &str) {\n        log_info!(\"Opening {} in Wireshark\", file_path);\n        // Would call network_monitor.launch_wireshark()\n    }\n\n    fn apply_arch_optimizations(&mut self) {\n        log_info!(\"Applying Arch Linux optimizations\");\n        // Would call arch_manager.optimize_for_virtualization()\n    }\n}\n\nimpl Default for NetworkingGui {\n    fn default() -> Self {\n        Self::new()\n    }\n}"