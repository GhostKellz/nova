use crate::console::{ConsoleManager, ConsoleSession, ConsoleType, ConnectionInfo, ConsoleConfig};\nuse crate::rustdesk_integration::{RustDeskManager, RustDeskConfig, RustDeskSession, PerformanceProfile};\nuse crate::{log_debug, log_error, log_info, log_warn, NovaError, Result};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EnhancedConsoleConfig {\n    pub standard_console: ConsoleConfig,\n    pub rustdesk_config: RustDeskConfig,\n    pub preferred_protocol: PreferredProtocol,\n    pub auto_install_agents: bool,\n    pub performance_monitoring: bool,\n    pub session_recording: bool,\n    pub multi_monitor_support: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum PreferredProtocol {\n    RustDesk,     // Highest performance\n    SPICE,        // Good performance, native libvirt\n    VNC,          // Universal compatibility\n    Auto,         // Auto-select based on VM capabilities\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UnifiedConsoleSession {\n    pub vm_name: String,\n    pub session_id: String,\n    pub protocol_used: ActiveProtocol,\n    pub performance_score: f32,\n    pub created_at: chrono::DateTime<chrono::Utc>,\n    pub last_accessed: chrono::DateTime<chrono::Utc>,\n    pub active: bool,\n    pub features: SessionFeatures,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ActiveProtocol {\n    RustDesk(RustDeskSession),\n    Standard(ConsoleSession),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SessionFeatures {\n    pub file_transfer: bool,\n    pub clipboard_sync: bool,\n    pub audio_enabled: bool,\n    pub multi_monitor: bool,\n    pub hardware_acceleration: bool,\n    pub encryption: bool,\n    pub recording: bool,\n}\n\npub struct EnhancedConsoleManager {\n    config: EnhancedConsoleConfig,\n    console_manager: ConsoleManager,\n    rustdesk_manager: RustDeskManager,\n    unified_sessions: Arc<Mutex<HashMap<String, UnifiedConsoleSession>>>,\n    performance_scores: Arc<Mutex<HashMap<String, f32>>>,\n}\n\nimpl EnhancedConsoleManager {\n    pub fn new(config: EnhancedConsoleConfig) -> Self {\n        let console_manager = ConsoleManager::new(config.standard_console.clone());\n        let rustdesk_manager = RustDeskManager::new(config.rustdesk_config.clone());\n        \n        Self {\n            config,\n            console_manager,\n            rustdesk_manager,\n            unified_sessions: Arc::new(Mutex::new(HashMap::new())),\n            performance_scores: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    /// Create the best possible console connection for a VM\n    pub async fn create_optimal_console(\n        &mut self, \n        vm_name: &str, \n        vm_ip: Option<&str>\n    ) -> Result<UnifiedConsoleSession> {\n        log_info!(\"Creating optimal console connection for VM: {}\", vm_name);\n\n        // Analyze VM capabilities and network conditions\n        let vm_analysis = self.analyze_vm_capabilities(vm_name, vm_ip).await?;\n        \n        // Select the best protocol based on analysis\n        let selected_protocol = self.select_optimal_protocol(&vm_analysis).await;\n        \n        log_info!(\"Selected protocol for VM '{}': {:?}\", vm_name, selected_protocol);\n\n        let session = match selected_protocol {\n            PreferredProtocol::RustDesk => {\n                self.create_rustdesk_session(vm_name, vm_ip, vm_analysis).await?\n            }\n            PreferredProtocol::SPICE => {\n                self.create_spice_session(vm_name, vm_analysis).await?\n            }\n            PreferredProtocol::VNC => {\n                self.create_vnc_session(vm_name, vm_analysis).await?\n            }\n            PreferredProtocol::Auto => {\n                // This should not happen as select_optimal_protocol returns specific protocol\n                self.create_rustdesk_session(vm_name, vm_ip, vm_analysis).await?\n            }\n        };\n\n        // Start performance monitoring\n        if self.config.performance_monitoring {\n            self.start_performance_monitoring(&session.session_id).await?;\n        }\n\n        // Store session\n        {\n            let mut sessions = self.unified_sessions.lock().unwrap();\n            sessions.insert(session.session_id.clone(), session.clone());\n        }\n\n        log_info!(\"Optimal console session created: {} (score: {:.2})\", \n                 session.session_id, session.performance_score);\n        \n        Ok(session)\n    }\n\n    async fn create_rustdesk_session(\n        &mut self, \n        vm_name: &str, \n        vm_ip: Option<&str>, \n        analysis: VmAnalysis\n    ) -> Result<UnifiedConsoleSession> {\n        log_info!(\"Creating RustDesk session for VM: {}\", vm_name);\n        \n        let vm_ip = vm_ip.ok_or_else(|| {\n            log_error!(\"VM IP required for RustDesk connection\");\n            NovaError::SystemCommandFailed\n        })?;\n\n        // Determine optimal performance profile\n        let performance_profile = self.determine_performance_profile(&analysis);\n        \n        let rustdesk_session = self.rustdesk_manager\n            .create_rustdesk_session(vm_name, vm_ip, performance_profile)\n            .await?;\n\n        let features = SessionFeatures {\n            file_transfer: true,\n            clipboard_sync: true,\n            audio_enabled: true,\n            multi_monitor: analysis.supports_multi_monitor,\n            hardware_acceleration: analysis.has_gpu,\n            encryption: true,\n            recording: self.config.session_recording,\n        };\n\n        let session = UnifiedConsoleSession {\n            vm_name: vm_name.to_string(),\n            session_id: rustdesk_session.session_id.clone(),\n            protocol_used: ActiveProtocol::RustDesk(rustdesk_session),\n            performance_score: 95.0, // RustDesk gets highest score\n            created_at: chrono::Utc::now(),\n            last_accessed: chrono::Utc::now(),\n            active: true,\n            features,\n        };\n\n        Ok(session)\n    }\n\n    async fn create_spice_session(\n        &mut self, \n        vm_name: &str, \n        analysis: VmAnalysis\n    ) -> Result<UnifiedConsoleSession> {\n        log_info!(\"Creating SPICE session for VM: {}\", vm_name);\n        \n        let console_session = self.console_manager\n            .create_spice_console(vm_name)\n            .await?;\n\n        let features = SessionFeatures {\n            file_transfer: false, // SPICE doesn't have native file transfer\n            clipboard_sync: true,\n            audio_enabled: true,\n            multi_monitor: analysis.supports_multi_monitor,\n            hardware_acceleration: analysis.has_gpu,\n            encryption: false,\n            recording: false,\n        };\n\n        let session = UnifiedConsoleSession {\n            vm_name: vm_name.to_string(),\n            session_id: console_session.session_id.clone(),\n            protocol_used: ActiveProtocol::Standard(console_session),\n            performance_score: 75.0, // SPICE gets good score\n            created_at: chrono::Utc::now(),\n            last_accessed: chrono::Utc::now(),\n            active: true,\n            features,\n        };\n\n        Ok(session)\n    }\n\n    async fn create_vnc_session(\n        &mut self, \n        vm_name: &str, \n        analysis: VmAnalysis\n    ) -> Result<UnifiedConsoleSession> {\n        log_info!(\"Creating enhanced VNC session for VM: {}\", vm_name);\n        \n        let console_session = self.console_manager\n            .create_vnc_console(vm_name, true) // Enhanced VNC\n            .await?;\n\n        let features = SessionFeatures {\n            file_transfer: false,\n            clipboard_sync: false,\n            audio_enabled: false,\n            multi_monitor: false,\n            hardware_acceleration: false,\n            encryption: self.config.standard_console.ssl_enabled,\n            recording: false,\n        };\n\n        let session = UnifiedConsoleSession {\n            vm_name: vm_name.to_string(),\n            session_id: console_session.session_id.clone(),\n            protocol_used: ActiveProtocol::Standard(console_session),\n            performance_score: 50.0, // VNC gets basic score\n            created_at: chrono::Utc::now(),\n            last_accessed: chrono::Utc::now(),\n            active: true,\n            features,\n        };\n\n        Ok(session)\n    }\n\n    async fn analyze_vm_capabilities(\n        &self, \n        vm_name: &str, \n        vm_ip: Option<&str>\n    ) -> Result<VmAnalysis> {\n        log_info!(\"Analyzing VM capabilities: {}\", vm_name);\n        \n        let mut analysis = VmAnalysis::default();\n        \n        // Check VM specs via libvirt\n        if let Ok(output) = tokio::process::Command::new(\"virsh\")\n            .args(&[\"dominfo\", vm_name])\n            .output()\n            .await\n        {\n            let info = String::from_utf8_lossy(&output.stdout);\n            \n            // Parse CPU and memory info\n            if let Some(cpu_line) = info.lines().find(|line| line.contains(\"CPU(s)\")) {\n                if let Some(cpu_str) = cpu_line.split_whitespace().nth(1) {\n                    analysis.cpu_cores = cpu_str.parse().unwrap_or(1);\n                }\n            }\n            \n            if let Some(mem_line) = info.lines().find(|line| line.contains(\"Max memory\")) {\n                if let Some(mem_str) = mem_line.split_whitespace().nth(2) {\n                    analysis.memory_mb = mem_str.parse().unwrap_or(1024);\n                }\n            }\n        }\n        \n        // Check for GPU passthrough\n        if let Ok(output) = tokio::process::Command::new(\"virsh\")\n            .args(&[\"dumpxml\", vm_name])\n            .output()\n            .await\n        {\n            let xml = String::from_utf8_lossy(&output.stdout);\n            analysis.has_gpu = xml.contains(\"<hostdev\") && xml.contains(\"type='pci'\");\n        }\n        \n        // Check network connectivity and latency if IP provided\n        if let Some(ip) = vm_ip {\n            analysis.network_latency_ms = self.measure_network_latency(ip).await;\n            analysis.network_bandwidth_mbps = self.measure_network_bandwidth(ip).await;\n        }\n        \n        // Detect OS type and capabilities\n        analysis.os_type = self.detect_os_type(vm_name).await;\n        analysis.supports_guest_agent = self.check_guest_agent(vm_name).await;\n        \n        // Multi-monitor support (mainly for SPICE and RustDesk)\n        analysis.supports_multi_monitor = analysis.has_gpu || \n            matches!(analysis.os_type.as_str(), \"windows\" | \"linux\");\n        \n        log_info!(\"VM analysis complete for '{}': {} cores, {}MB RAM, GPU: {}, OS: {}\", \n                 vm_name, analysis.cpu_cores, analysis.memory_mb, \n                 analysis.has_gpu, analysis.os_type);\n        \n        Ok(analysis)\n    }\n\n    async fn select_optimal_protocol(&self, analysis: &VmAnalysis) -> PreferredProtocol {\n        match self.config.preferred_protocol {\n            PreferredProtocol::Auto => {\n                // Intelligent protocol selection based on VM capabilities\n                \n                // RustDesk is preferred for high-performance scenarios\n                if analysis.cpu_cores >= 2 && \n                   analysis.memory_mb >= 2048 && \n                   analysis.network_latency_ms < 50.0 {\n                    return PreferredProtocol::RustDesk;\n                }\n                \n                // SPICE for good balance with libvirt integration\n                if analysis.supports_guest_agent && \n                   analysis.cpu_cores >= 1 {\n                    return PreferredProtocol::SPICE;\n                }\n                \n                // VNC as fallback\n                PreferredProtocol::VNC\n            }\n            other => other\n        }\n    }\n\n    fn determine_performance_profile(&self, analysis: &VmAnalysis) -> PerformanceProfile {\n        // Select optimal RustDesk performance profile based on VM capabilities\n        \n        if analysis.has_gpu && \n           analysis.cpu_cores >= 4 && \n           analysis.memory_mb >= 4096 && \n           analysis.network_bandwidth_mbps >= 100.0 {\n            PerformanceProfile::UltraHigh\n        } else if analysis.cpu_cores >= 2 && \n                  analysis.memory_mb >= 2048 && \n                  analysis.network_bandwidth_mbps >= 50.0 {\n            PerformanceProfile::High\n        } else if analysis.network_bandwidth_mbps < 10.0 {\n            PerformanceProfile::LowBandwidth\n        } else {\n            PerformanceProfile::Balanced\n        }\n    }\n\n    async fn measure_network_latency(&self, ip: &str) -> f32 {\n        // Measure ping latency to VM\n        if let Ok(output) = tokio::process::Command::new(\"ping\")\n            .args(&[\"-c\", \"3\", ip])\n            .output()\n            .await\n        {\n            let ping_output = String::from_utf8_lossy(&output.stdout);\n            if let Some(avg_line) = ping_output.lines().find(|line| line.contains(\"avg\")) {\n                if let Some(avg_str) = avg_line.split('/').nth(4) {\n                    return avg_str.parse().unwrap_or(100.0);\n                }\n            }\n        }\n        100.0 // Default high latency\n    }\n\n    async fn measure_network_bandwidth(&self, ip: &str) -> f32 {\n        // Quick bandwidth test (simplified)\n        // In production, could use iperf3 or similar\n        if self.measure_network_latency(ip).await < 10.0 {\n            1000.0 // Assume gigabit for low latency (LAN)\n        } else if self.measure_network_latency(ip).await < 50.0 {\n            100.0  // Assume 100Mbps for moderate latency\n        } else {\n            10.0   // Assume 10Mbps for high latency\n        }\n    }\n\n    async fn detect_os_type(&self, vm_name: &str) -> String {\n        // Try to detect OS via guest agent or XML analysis\n        if let Ok(output) = tokio::process::Command::new(\"virsh\")\n            .args(&[\"qemu-agent-command\", vm_name, \"{\\\"execute\\\":\\\"guest-get-osinfo\\\"}\"])\n            .output()\n            .await\n        {\n            if output.status.success() {\n                let response = String::from_utf8_lossy(&output.stdout);\n                if response.contains(\"Windows\") {\n                    return \"windows\".to_string();\n                } else if response.contains(\"Linux\") {\n                    return \"linux\".to_string();\n                } else if response.contains(\"Darwin\") {\n                    return \"macos\".to_string();\n                }\n            }\n        }\n        \"unknown\".to_string()\n    }\n\n    async fn check_guest_agent(&self, vm_name: &str) -> bool {\n        tokio::process::Command::new(\"virsh\")\n            .args(&[\"qemu-agent-command\", vm_name, \"{\\\"execute\\\":\\\"guest-ping\\\"}\"])\n            .output()\n            .await\n            .map(|output| output.status.success())\n            .unwrap_or(false)\n    }\n\n    async fn start_performance_monitoring(&self, session_id: &str) -> Result<()> {\n        log_info!(\"Starting performance monitoring for session: {}\", session_id);\n        \n        let session_id_clone = session_id.to_string();\n        let scores_clone = self.performance_scores.clone();\n        \n        tokio::spawn(async move {\n            loop {\n                // Collect performance metrics and calculate score\n                let score = Self::calculate_performance_score(&session_id_clone).await;\n                \n                {\n                    let mut scores = scores_clone.lock().unwrap();\n                    scores.insert(session_id_clone.clone(), score);\n                }\n                \n                tokio::time::sleep(tokio::time::Duration::from_secs(10)).await;\n            }\n        });\n        \n        Ok(())\n    }\n\n    async fn calculate_performance_score(session_id: &str) -> f32 {\n        // Calculate performance score based on multiple factors:\n        // - Latency\n        // - FPS\n        // - Bandwidth usage\n        // - CPU/Memory usage\n        \n        // Simplified scoring for now\n        85.0\n    }\n\n    // Public API methods\n    pub fn list_active_sessions(&self) -> Vec<UnifiedConsoleSession> {\n        let sessions = self.unified_sessions.lock().unwrap();\n        sessions.values().filter(|s| s.active).cloned().collect()\n    }\n\n    pub fn get_session(&self, session_id: &str) -> Option<UnifiedConsoleSession> {\n        let sessions = self.unified_sessions.lock().unwrap();\n        sessions.get(session_id).cloned()\n    }\n\n    pub fn get_performance_score(&self, session_id: &str) -> Option<f32> {\n        let scores = self.performance_scores.lock().unwrap();\n        scores.get(session_id).copied()\n    }\n\n    pub async fn close_session(&mut self, session_id: &str) -> Result<()> {\n        log_info!(\"Closing unified console session: {}\", session_id);\n        \n        if let Some(session) = self.get_session(session_id) {\n            match session.protocol_used {\n                ActiveProtocol::RustDesk(_) => {\n                    self.rustdesk_manager.disconnect_session(session_id).await?\n                }\n                ActiveProtocol::Standard(_) => {\n                    self.console_manager.close_session(session_id).await?\n                }\n            }\n        }\n        \n        // Remove from unified sessions\n        {\n            let mut sessions = self.unified_sessions.lock().unwrap();\n            sessions.remove(session_id);\n        }\n        \n        {\n            let mut scores = self.performance_scores.lock().unwrap();\n            scores.remove(session_id);\n        }\n        \n        Ok(())\n    }\n\n    /// Switch protocols for an active session (if possible)\n    pub async fn switch_protocol(\n        &mut self, \n        session_id: &str, \n        new_protocol: PreferredProtocol\n    ) -> Result<UnifiedConsoleSession> {\n        log_info!(\"Switching protocol for session: {} to {:?}\", session_id, new_protocol);\n        \n        // Get current session\n        let current_session = self.get_session(session_id)\n            .ok_or(NovaError::NetworkNotFound(session_id.to_string()))?;\n        \n        // Close current session\n        self.close_session(session_id).await?;\n        \n        // Create new session with different protocol\n        self.config.preferred_protocol = new_protocol;\n        \n        // Determine VM IP from current session if needed\n        let vm_ip = match &current_session.protocol_used {\n            ActiveProtocol::RustDesk(rd_session) => {\n                // Extract IP from RustDesk session if available\n                Some(\"192.168.1.100\") // Placeholder\n            }\n            ActiveProtocol::Standard(_) => None,\n        };\n        \n        self.create_optimal_console(&current_session.vm_name, vm_ip).await\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct VmAnalysis {\n    cpu_cores: u32,\n    memory_mb: u64,\n    has_gpu: bool,\n    network_latency_ms: f32,\n    network_bandwidth_mbps: f32,\n    os_type: String,\n    supports_guest_agent: bool,\n    supports_multi_monitor: bool,\n}\n\nimpl Default for VmAnalysis {\n    fn default() -> Self {\n        Self {\n            cpu_cores: 2,\n            memory_mb: 2048,\n            has_gpu: false,\n            network_latency_ms: 10.0,\n            network_bandwidth_mbps: 100.0,\n            os_type: \"unknown\".to_string(),\n            supports_guest_agent: false,\n            supports_multi_monitor: false,\n        }\n    }\n}\n\nimpl Default for EnhancedConsoleConfig {\n    fn default() -> Self {\n        Self {\n            standard_console: ConsoleConfig::default(),\n            rustdesk_config: RustDeskConfig::default(),\n            preferred_protocol: PreferredProtocol::Auto,\n            auto_install_agents: true,\n            performance_monitoring: true,\n            session_recording: false,\n            multi_monitor_support: true,\n        }\n    }\n}"